---
lang: fa
dir: rtl
---

# توضیحات پروژه

این پروژه یک سیستم مدیریت گراف وزنی برای برنامه‌ریزی سفرها و بهینه‌سازی مسیرها است. در این پروژه، از الگوریتم‌های مختلف برای ایجاد، مدیریت و بهینه‌سازی گراف‌ها استفاده شده است.

## الگوریتم‌ها و پیچیدگی زمانی

1. **الگوریتم Dijkstra**:
   - برای پیدا کردن کوتاه‌ترین مسیر بین دو گره استفاده می‌شود.
   - پیچیدگی زمانی: O((V + E) log V) با استفاده از یک صف اولویت با هیپ دودویی.
   - این الگوریتم برای پیدا کردن بهترین مسیر ممکن بین دو نقطه در گراف استفاده می‌شود.

2. **الگوریتم Minimum Spanning Tree (MST)**:
   - برای ایجاد یک درخت پوشا با حداقل وزن استفاده می‌شود.
   - پیچیدگی زمانی: O(E log E) با استفاده از الگوریتم Kruskal.
   - این الگوریتم تضمین می‌کند که هر گره در گراف از طریق حداکثر دو گره دیگر قابل دسترسی است.

3. **الگوریتم Held-Karp برای مسئله فروشنده دوره‌گرد (TSP)**:
   - برای پیدا کردن کوتاه‌ترین مسیر ممکن که از تمام گره‌ها عبور می‌کند استفاده می‌شود.
   - پیچیدگی زمانی: O(n^2 2^n) که n تعداد گره‌ها است.
   - این الگوریتم برای سفرهای چند توقفی استفاده می‌شود.

<!-- 4. **الگوریتم Divide and Conquer**:
    - برای بهبود کارایی محاسباتی در گراف‌های بزرگ استفاده می‌شود.
    - پیچیدگی زمانی: بستگی به گروه بندی کاربر دارد، اما هدف کاهش پیچیدگی با تقسیم گراف به بخش‌های کوچکتر است.
    - این الگوریتم شامل انتخاب گره‌های با بالاترین درجه، گروه‌بندی گره‌هایی که در حداکثر 2 هاپ از گره مرکزی قرار دارند و ایجاد یک گراف با درجه بالاتر است. -->

## انتخاب‌های طراحی

1. **گراف وزنی**:
   - پیاده‌سازی گراف وزنی برای نمایش مسیرها و وزن‌های مختلف بین گره‌ها.
   - این طراحی امکان مدیریت و بهینه‌سازی مسیرها را فراهم می‌کند.

2. **صف اولویت**:
   - برای مدیریت مسیرهایی که به حداکثر ظرفیت خود رسیده‌اند استفاده می‌شود.
   - این طراحی کمک می‌کند تا مسیرها به صورت کارآمد مدیریت شوند.

3. **منوی نمایش سفر**:
   - برای نمایش اطلاعات سفرها مانند زمان شروع، زمان پایان و مدت زمان سفر استفاده می‌شود.
   - این طراحی به کاربران امکان می‌دهد تا سفرهای خود را به راحتی مدیریت کنند.

4. **نقشه حرارتی**:
   - برای نمایش اطلاعات ترافیکی بین گره‌ها استفاده می‌شود.
   - این طراحی کمک می‌کند تا اطلاعات ترافیکی به صورت بصری نمایش داده شوند.

5. **تایید تغییرات گراف**:
   - برای تایید تغییرات در گراف مانند اضافه یا حذف گره‌ها و لبه‌ها استفاده می‌شود.
   - این طراحی کمک می‌کند تا تغییرات به صورت ایمن و قابل کنترل انجام شوند.

6. **استفاده از Cytoscape**:
   - برای نمایش تمیز و قوی گراف‌ها استفاده می‌شود.
   - این کتابخانه امکان نمایش بصری و تعاملی گراف‌ها را فراهم می‌کند.

7. **User Intent Interface (UII)**:
   - استفاده از LLM و فراخوانی تابع به جای یک رابط کاربری پر از کلید‌های مختلف.
   - این طراحی امکان تعامل طبیعی و کارآمد با سیستم را فراهم می‌کند.

8. **Cerebras**:
   - برای استنتاج سریع هوش مصنوعی استفاده می‌شود.
   - این فناوری امکان پردازش سریع و کارآمد مدل‌های هوش مصنوعی را فراهم می‌کند.

9. **Llama 3.3 70B**:
   - به عنوان یک مدل زبان بزرگ و هوشمند استفاده می‌شود.
   - این مدل امکان پردازش و تولید متن با کیفیت بالا را فراهم می‌کند.

10. **ماژولاریته و ساختار پروژه تمیز**:
    - طراحی ماژولار و ساختار تمیز پروژه برای مدیریت و توسعه آسان.
    - این طراحی امکان نگهداری و توسعه آسان پروژه را فراهم می‌کند.

11. **MarkdownIt**:
    - برای فرمت‌بندی پاسخ‌های LLM استفاده می‌شود.
    - این کتابخانه امکان نمایش متن با فرمت مناسب را فراهم می‌کند.

12. **SvelteKit**:
    - یک چارچوب UI سریع، قوی و مدرن برای توسعه رابط کاربری.
    - این چارچوب امکان ایجاد رابط‌های کاربری سریع و کارآمد را فراهم می‌کند.
